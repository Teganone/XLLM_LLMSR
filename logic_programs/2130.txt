# Declarations
candidates = EnumSort([Cheng_Qiang, Julie, Li_Ping, Xue_Fang])
qualifies1 = Function([candidates] -> [bool])
qualifies2 = Function([candidates] -> [bool])
qualifies3 = Function([candidates] -> [bool])

# Constraints
Count([c for c in candidates if qualifies1(c) == True]) == 3 ::: (4) Three meet condition①
Count([c for c in candidates if qualifies2(c) == True]) == 2 ::: (4) Two meet condition②
Count([c for c in candidates if qualifies3(c) == True]) == 1 ::: (4) One meets condition③
ForAll([c for c in candidates], (qualifies1(c) or qualifies2(c) or qualifies3(c)) == True) ::: (4) Each person meets at least one condition
((not qualifies1(Cheng_Qiang) and qualifies1(Julie)) or (qualifies1(Cheng_Qiang) and not qualifies1(Julie))) ::: (1) One of Cheng_Qiang and Julie has only attended undergraduate
qualifies1(Julie) == qualifies1(Xue_Fang) ::: (2) Julie and Xue_Fang have the same final education
qualifies2(Li_Ping) == qualifies2(Xue_Fang) ::: (3) Li Ping and Xue_Fang have similar English conversation skills
qualifies1(Julie) == True ::: (2) from cot_parsing verification
qualifies1(Xue_Fang) == True ::: (2) from cot_parsing verification
qualifies2(Li_Ping) == True ::: (3) from cot_parsing verification
qualifies2(Xue_Fang) == True ::: (3) from cot_parsing verification

# Verifications
is_deduced((not qualifies1(Cheng_Qiang) and not qualifies1(Julie)), False) ::: (1) Neither Cheng_Qiang nor Julie can meet condition① is not applicable
is_deduced((qualifies1(Julie) and qualifies1(Xue_Fang)), True) ::: (2) Julie and Xue_Fang both meet condition①
is_deduced((qualifies2(Li_Ping) and qualifies2(Xue_Fang)), True) ::: (3) Li Ping and Xue_Fang both meet condition②
is_deduced(ForAll([c for c in candidates], Implies((qualifies1(c) and qualifies2(c) and qualifies3(c)), c == Xue_Fang)), True) ::: (4) Xue_Fang is the accepted candidate